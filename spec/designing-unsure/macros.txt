#
# Dependencies: annotation, basic, const, export, fnStat, library(TODO), type
#

"std::macros" Module {
	
	--These types are only available at const tune
	
	ex struct Block = @Builtin{"base::type/block"}Unit;
	ex struct Stat = @Builtin{"base::type/stat"}Unit;
	
	ex struct Expr = @Builtin{"base::type/expr"}Unit;
	ex struct Name = @Builtin{"base::type/Name"}Unit;
	
	--
	--wrap around one of the above things, to allow a list of someting
	--note: only works for: (Name,Expr)
	--
	ex struct fn CommaList(T = type) = @Builtin{"base::type/CommaList"}T;
	
	--These return the tokens raw, without splicing them
	
	--Do NOT use @Builtin{"base::no_splice"} in your own code, as it is only supported here.
	--The ! after the name, makes it so it doesnt conflict with the types.
	--It also means you cant call these in function-form
	@Builtin{"base::no_splice"} ex macro fn Block!{macro v = Block}->Block {return v;}
	
	@Builtin{"base::no_splice"} ex macro fn Stat! {macro v = Stat }->Stat {return v;}
	
	@Builtin{"base::no_splice"} ex macro fn Expr! {macro v = Expr }->Expr {return v;}
	@Builtin{"base::no_splice"} ex macro fn Name! {macro v = Name }->Name {return v;}
	
	@Builtin{"base::no_splice"} ex macro fn CommaList!{T = type,macro v = CommaList(T)}->CommaList(T) {return v;}
	
	--[=[
	--TODO: move this elsewhere, when its needed
		fn prefixUpperify(prefix = *str,s = mut String) -> String {
			if (s.len() == 0) return prefix;
			s[1] = s[1].upper()
			return prefix++s;
		}
	]=]
	
	--[=[
	
	--
	-- This is a example, for how to create a macro that instantly splices what you pass to it
	--
	-- (addType!{u8}) -> (u8)
	--
	-- You can also call it like a normal function (you also need to use "()"),
	-- and it will return what you called it with, and nothing will change.
	--
	-- assertEq!(addType(Expr!{u8}), Expr!{u8});
	--
	
	macro fn implAdd(macro ns = CommaList(Name)) -> Vec(Stat) {
		
		let Vec(Stat) r;
		
		for (k,v in ns) {
			let name = ("add"++(v as str)) as Name;
			r:push(
				Stat!{
					ex macro fn @(name) {macro @(v) val } {
						return val
					}
				}
			);
		}
		
		return r;
	}
	
	implAdd!(
		Block,
		Stat,
		
		Expr,
		Name
	);
	]=]
	
	Implementation {
		The types may be implemented as "Userdata" or "ptrdata", with extra data
		
		Using them outside of const time or macros must produce a compile-time error
	}
}


New Syntax {

	macroSplice ::= "@(" expr ")"
	
	macroArgs ::= "(" ProgrammableArgs ")" | "{" ProgrammableArgs "}" | "[" ProgrammableArgs "]" | expr | stat | retstat
	
	-- The `!` char must be without any white-space in between
	macroInvoke ::= modpath"!" macroArgs
	macroInvSpl ::= macroInvoke | macroSplice
	
	globstat @::= | macroInvSpl
	Name @::=|macroInvSpl
	optexport @::= | macroInvSpl
	
	macroParam ::= ["macro"] typedParam
	macroparams ::= {macroParam fieldsep}
	
	macroParamsBlock ::= ("(" macroparams ")")
		| ("[" macroparams "]")
		| ("{" macroparams "}") 
		| (">!(" macroparams ")!<")
	
	globstat @::= | optexport "macro" "fn" Name macroParamsBlock ["->" basicExpr] "{" block "}"
}

New Keywords {
	macro
}

New Tokens {
	>!(
	@(
	)!<
	)	--match the parens
	!
	->
}

Macro {
	
	--TODO: a way to splice out basic keywords, like "mut", "ex" and "const"
	-- maybe token sequences?
	
	Creates a new global or local macro with a name `Name`, that cant be modified.
	These macros are hygenic, so no variables can be implicitly shared between the macro and the outside world.
	
	Macro's must return one of the macro types (or a simple container of them), if you need to return something else, use a const function.
	

	macroSplice -> splices the token sequence(s) resulting from a expresion
	macroInvoke -> run a macro & splice it.
	The ">!(" ")!<" args mean that there is nothing surrounding the args.
	"macro" functions are ran at compilation time.
	
	macroInvoke gets turned from 
	```slu
	macroWithArgs_Name_Stat!(myNameArg,local x = 44)
	```
	into 
	```slu
	@(macroWithArgs_Name_Stat(Name!{myNameArg},Stat!{local x = 44}))
	```
	
	Adding "macro" before a argument, makes it modify parsing behaviour, when
		using "macroInvoke", if there is no macro, then you need to pass it by value.
	
	You can call macro-functions like normal const functions.
	When doing that, you also need to use "()".
	
	When using ">!( )!<", you cant have more than 1 argument, and it cant be a list.
	
	If you have a CommaList in your args, it must be the last argument.
	
	adding a ! after the name of a macro def, makes it so it doesnt
	conflict with existing symbols,	it also means you cant call them in function-form
	
	@@ is converted to @.
	
	Error messages from macro code include both the macro splice-stack, and the place where it was spliced from.
	
	Implementation {
		
		Could be parsed without resolving into syntax elements, and then desugared into the real expression, statement, etc.
		
		Could be implemented by wrapping the input stream temporarily, while something needs to be spliced in.
	}
}