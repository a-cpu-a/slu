#
# Dependencies: basic, type, const
#

New Syntax {

	--(sPat) Note: the `and` and `or` operators are reserved.
	--(sPat) Note: || lambdas are not parsed. Aka `|...| ...`
	--(sPat) Note: table constructors are not parsed.
	sPat ::= basicExpr
	
	destrSpec ::= sPat | ["mut"] {typePreop}
	destrField ::= "|" tupleableName "|" pat
	
	dPat ::= destrSpec "{" {destrField fieldsep} [".."] "}"
		| destrSpec "{" {pat fieldsep} [".."] "}"
		
		| destrSpec Name ["=" sPat] 
		| "_"
	
	
	destrFieldUncond ::= "|" tupleableName "|" uncondDestrPat
	
	uncondDestrPat ::= destrSpec "{" {destrFieldUncond fieldsep} [".."] "}"
		| destrSpec "{" {uncondDestrPat fieldsep} [".."] "}"
		
		| destrSpec Name
		| "_"
	
	pat ::= sPat | dPat
	
	matchItem ::= pat ["if" expr] "=>" expr
	matchtypeblock ::= ["->" basicExpr] "{" matchItem [";"] {matchItem [";"]} "}"
	statOrExpr @::= | "match" basicExpr matchtypeblock
}

New Keywords {
	if
	match
}

New Tokens {
	|
	=>
	=
	..
	;
	,
	->
	_
}

Match {
	
	--TODO: do we even need restrictions?
	-- the only loss would be `5 or 7 or 11` type of stuff, unless you type it out using a `if`
	
	Lets you match on a expressions result.
	
	The return type is assigned automatically, if missing.
	
	First matching pattern will be used. (top to bottom)
	The order inside the patterns is undefined.
	
	Match statements must always handle all inputs.
	If some inputs wouldnt match, then a soft-error occurs, and a " else => panic!(); " is inserted.
	It is an soft-error to have multiple cases that are identical, without any if checks.
	
	".." is required, when a field / array element is ignored, or when matching on dynamicaly-sized arrays.
	
	Implementation {
		May be a jump table, if else chain, etc.
	}
}