#
# Dependencies: basic, const, modules, numbers, safety
#

New Syntax {
	
	--TODO: allow fixed points `(0..255) * 0.125` or `0..31.875 at 0.125`
	
	refAttrs ::= [addrspace] [lifetime] [refType]
	refType ::= "const" | "share" | "mut"

	typePreop ::= "*" refAttrs
	
	binop @::= | "~" | "|"
	preop @::= | typePreop | "ex" | "mut" | "[" "]" | "dyn" | "impl" | "union" | "&" refAttrs | "~"
	
	lifetime ::= "/" Name {"/" Name}
	addrspace ::= "in" Name
	
	typedParam ::= ["const"] Name "=" expr
	params ::= typedParam fieldsep {typedParam fieldsep}
	selfParams ::= [{("*") [refType]} "self" fieldsep] params
	
	basicExpr @::= | "_" | lifetime
}

New Keywords {
	struct
	union
	const
	share
	impl
	dyn
	mut
	ex
}

New Tokens {
	~
	|
	&
	/
	*
	,
	_
}

New types {

	trait
	type
	
	Impl
	Dyn
	
	Life
	Space
	
	Ref
	RefShare
	RefMut
	Ptr
	PtrShare
	PtrMut
	Addr

	Unit
	Any
	str
	char
	String
	Result
	
	f8
	f16
	f32
	f64
	f128
	
	i8
	i16
	i32
	i64
	i128
	isize
	
	u8
	u16
	u32
	u64
	u128
	usize
	
	n8
	n16
	n32
	n64
	n128
	nsize
}

Official Types {

	(names starting with a capital are complex types)
	
	trait {
		Represents some trait (potentially a combination of them) as a value.
	}
	type {
		Represents some type as a value.
	}
	Impl {
		A type that implements a list of traits, eventually known at compile time.
		By default implies `impl Drop + Relocate + Sized + Aligned`.
		--TODO: maybe one day allow linear / higher-raii types: `impl ?Drop`
	}
	Dyn {
		A type that implements a list of traits.
		By default implies the same things as `impl` does.
	}
	Life {
		Represents some lifetime as a value.
	}
	Space {
		Represents some address space as a value.
	}
	Unit {
		A nominally unique unit type, used as the default type for some things.
	}
	
	Any {
		Any type is allowed
	}
	str {
		A slice of character units.
		
		a reference to a string of utf8 bytes, or utf16 chars.
		
		Must be valid utf16, with no malformed surrogate pairs, or valid utf8, using the old standard that allows charaters up to 32~ bits, without any surrogate pairs.
		
		On most hosts the contents are utf8, some hosts, like java & javascript use utf16, if any host uses utf8, then utf8 is used on all of them.
	}
	char {
		(TODO: some magic tricks to make the syntax *char: transparent structs?)
		A reference to a character inside a str, immutable.
		Must point to a valid character, because it doesnt store the size of it.
	}
	String {
		A mutable string.
		
		Same restrictions on content as "str".
		
		Creating invalid content isnt ub in itself, but some libraries or functions will not handle that correctly.
	}
	Result {
		Used for func return types, can also be created with the ~ operator.
		`u8~Ae` == `Result(u8,Ae)`
		`~Ae` == `Result(Unit,Ae)`
	}
	f8,f16,f128 {
		Reserved, may be used in the future.
		(intended for uses outside of simple hosts like lua, but will be supported inside them, when added)
	}
	f32,f64 {
		32 or 64 bit floats.
		
		Implementation {
			If f32/f64 is not natively supported, then it is emulated.
			If the native implementation has bugs, then it is also emulated.
		}
	}
	i8,i16,i32,i64,i128 {
		Optimized 8,16,32,64 or 128 bit signed integers.
		Implementation {
			i32, i64 may be emulated on platforms like luajit, or 32bit versions of lua.
			i128 is always emulated in lua.
		}
	}
	u8,u16,u32,u64,u128 {
		Optimized 8,16,32,64 or 128 bit unsigned integers.
		Implementation {
			u32, u64 may be emulated on platforms like luajit, or 32bit versions of lua.
			u64 multiplication, division, modulo, exp are all emulated on normal lua, (luajit might be optimized when possible).
			u128 is always emulated in lua.
		}
	}
	n8,n16,n32,n64,n128 {
		Optimized 8,16,32,64 or 128 bit unsigned integers with a +1, meaning 0 is not a valid number in these.
		Implementation {
			Could be a u___, but adding +1 when necessary.
			Could also be a u(___+1)
		}
	}
	usize {
		u32, u48, u54, u64, ... depending on platform.
	}
	isize {
		i___, same bits as usize
	}
	nsize {
		n___, same bits as usize
	}
}

Type Specifiers {
	
	-- In theory, there could be a refinement/liquid type specifier like this: "T : |v| v!=0 " or "T : myPredicateTakingT"
	-- this could also be chained: "T : |v| v!=0 : |v| v%2==0 : |v| v>-9999"
	-- it would be best to put the precedence above: mut, ~, but below: ++
	
	
	Slice {
		Format: "[" "]" X
		
		Unlike table arrays, negative or zero indices will error.
		Out of bounds access will also error.
		
		Implementation {
			Accessing elements through normal lua code is not supported, unless exported to lua.
			
			multi-dimensional arrays must not be flattened into 1 dimension, unless sizes can be predicted at compile time.
			
			The compiler must prove that indices will always be valid, before removing run-time checks.
		}
	}
	Result {
		Format: [X] "~" X
		
		Allows both a error, and a value, or just an error, and the value type is inferred.
		
		Allows use of the "?" operator, and other error handling tools.
	}
	Ref {
		Format "*" {lifetime} [refType] X
		
		Makes the type borrowing, this means that it is a borrowed value.
		
		nothing -> many references, immutable
		Const -> reserved
		Share -> many references, mutable
		Mut -> only 1 reference, mutable
		
		
		```slu
		let item1 = 4
		let item2 = 5
		
		let */item1 u8 myRef = &item1;
		
		let *mut u8 myRef2 = &mut item2;-- The annotation is inferred here.
		
		drop myRef2;-- Required, because not adding this, will produce a soft-error.
		
		let */item1/item2 u8 z = &item1;-- This requires dropping "myRef2", as you cant have 2 variables potentially holding a reference to the same variable.
		
		```
	}
	
	Deref {
		Format "Derefed" "(" X ")"

		--Maybe: Only allowed in the return type of functions.

		Represents a dereferenced borrow / ptr.
		
		```slu
		
		let intX = 4;
		
		let Derefed(*mut u8) xAlias = intX;
		xAlias = 3;
		drop xAlias; --Allow use of intX, once again
		
		assertEq!(intX,3);
		
		unsafe {
			let Derefed(PtrMut(u8)) xAliasUnsafe = _COMP_TODO!("turn into pointer",&mut intX).*;
			xAliasUnsafe = 2;
		}
		assertEq!(intX,2);
		
		
		let intXBorrow = &intX;
		
		let Derefed(*/intX u8) intXAlias = intXBorrow.*; --The type represents, a derefed reference for some u8 with lifetime "intX".
		let intXCopy = intXBorrow.*; --The type is just u8, as a trivial copy was possible.
		
		```
	}
	Pointer {
		Format ("Ptr"|"PtrConst"|"PtrShare"|"PtrMut") "(" X ")"
		
		Makes the type a pointer.
		
		```slu
		let firstArg = 1;
		let secondArg = 2;
		
		
		--Its (mostly) safe to make pointers, but not to use them.
		--Some hosts dont support pointers. (Most do, like js,java,lua,cpp, ...)
		
		let PtrConst(u8) myPtr = &const firstArg;
		
		let PtrMut(u8) myPtr2 = &mut secondArg;
		
		drop myPtr2;--Drops the pointer, not really meaningfull
		
		unsafe {
		let PtrMut(u8) firstArgPtr = &mut firstArg;
		
		firstArgPtr.!$TODO-choose-method-for-refification-or-use-a-unsafe-deref$!() = 4;
		}
		```
	}
}