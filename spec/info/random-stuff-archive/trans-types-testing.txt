~2025/05/24

trait InStream
{
	fn skipSpace(*mut self) trans self=>impl InStreamSkipSpace;
	fn dropSkipSpace(*mut self) trans self=>impl InStream;
	
	unsafe fn readNameUncheckedUntrans(*mut self) -> String;
	unsafe fn readNameUnchecked(*mut self) trans self=>impl InStream ->String {
	:::unsafe:
		return self.dropSkipSpace().readNameUncheckedUntrans();
	}
	fn readChar(*mut self) trans self=>impl InStream -> *char;
	fn curIdx(*self) -> uidx;
}
trait InStreamSkipSpace
{
	fn readName(*mut self) trans self=>impl InStream -> String {
	:::unsafe:
		return self.readNameUnchecked();
	}
}


--Vec in stream:

struct VecInStreamState(InStreamState state)
{
	idx=mut uidx,
	chars=mut Vec(*char)
};
const VecInStream = VecInStreamState(InStreamState::Default)
const VecInStreamSkipSpace = VecInStreamState(InStreamState::SkipSpace)

impl with(InStreamState state) 
	for VecInStreamState(state)
{
	fn curIdx(*self) -> uidx {
		return self.idx;
	}
	unsafe fn readNameUncheckedUntrans(*mut self) -> String {
	:::unsafe:
		return crate::internal::readNameUncheckedUntrans(self);
	}
	fn readChar(*mut self) trans
	{
		self.dropSkipSpace();
		self.idx+=1;
		return self.chars[self.idx-1];
	}
}
impl InStream for VecInStream
{
	fn skipSpace(*mut self) trans
	{
		--implemented in another file
		crate::internal::skipSpace(self);
		trans self = VecInStreamSkipSpace{idx=self.idx,chars=self.chars};
	} 
	--Empty, as you havent skipped any space.
	fn dropSkipSpace(*self) {}
	
}
impl InStream for VecInStreamSkipSpace
{
	--Empty, as you already skipped the space
	fn skipSpace(*self) {}
	fn dropSkipSpace(*mut self) trans {
		trans self = VecInStream{idx=self.idx,chars=self.chars};
	}
}
impl InStreamSkipSpace for VecInStreamSkipSpace {}
