-- Importing standard modules
use std::io;
use std::math;

-- Exporting a custom error type for our application
ex enum AppError {
    InvalidInput,
    Overflow,
    IOError
}

-- Define a struct with specific fields
-- Syntax is Name = Type inside the table constructor
struct Point {
    x = f32,
    y = f32
}

-- Implement a trait for the Point struct to give it a string representation
trait ToString {
    --[[AI used wrong naming convention]]
    fn to_string(*self) -> String;
}

impl ToString for Point {
    fn to_string(*self) -> String {
        -- String concatenation using the ++ operator
        return "Point{x: " ++ self.x.to_string() ++ ", y: " ++ self.y.to_string() ++ "}";
    }
}

-- A generic function that returns a Result type
-- The syntax `T ~ AppError` defines a Result type that is either T or AppError
-- Parameters use `Name = Type` syntax
fn calculate_square_root(n = f64) -> f64 ~ AppError {
    if n < 0.0 {
        throw AppError::InvalidInput;
    }
    
    -- Using a comptime block to ensure this constant calculation is done at compile time
    const epsilon = 0.00001;
    
    -- Mock algorithm for square root
    -- (In a real scenario, you would call a math library function)
    if n == 0.0 do--[[AI didnt add `do`]] {
        return 0.0;
    }
    return n; 
}

--[[AI, what...., I guess its technically correct? a zst tho, although it doesnt have the return type!]]
-- Example of a struct function that returns a nominal type
struct fn Dimensions(width = u32, height = u32) {
    -- Returns a struct that represents specific dimensions
    return struct { 
        width = width, 
        height = height,
        area = width * height
    };
}

-- Entry point of the application
-- The @Entrypoint annotation marks this as the main function to be executed
@Entrypoint{"main"}
ex fn main() {
    -- 1. Basic Variable Declarations
    -- Type inference is used here
    let greeting = "Hello, Slu!";
    --[[AI used macros, but i dont think we will do that, oh and it didnt use the cap-traits]]
    println!("{}", greeting);

    -- 2. Mutable variables and basic math with explicit types
    -- Syntax: `let [mut] Type Name = Value`
    let mut u8 counter = 0;
    counter = counter + 1;--[[AI didnt expect this to fail type checking due to potential overflow]]
    println!("Counter: {}", counter);

    -- 3. Using Structs and Traits
    let p = Point{x = 10.5, y = 20.0};
    println!("{}", p.to_string());

    -- 4. Control Flow: If Expressions
    -- `if` can be used as an expression returning a value
    let description = if counter > 0 => "Positive" else "Zero or Negative";
    println!("Status: {}", description);

    -- 5. Loops
    
    -- While loop
    let mut i = 0;--[[AI assumed this will infer into a type, but that is not trivial, and impossible in some cases. also overflow issue later on.]]
    while i < 3 {
        println!("While loop iteration: {}", i);
        i = i + 1;
    }

    -- For loop with Range operator (..)
    -- The range operator X..Y is inclusive [X, Y]
    for n in 1..3 {
        println!("For loop: {}", n); -- Prints 1, 2, 3
    }

    -- Infinite loop with break value
    let found = loop {
        counter = counter + 1;
        if counter == 5 {
            break counter * 2; -- Returns 10
        }
    };
    println!("Loop result: {}", found);

    -- 6. Error Handling with Try and Match
    
    -- Try block to handle potential errors from calculate_square_root
    let result = calculate_square_root(-4.0) try {
        AppError::InvalidInput => {
            println!("Error: Input cannot be negative.");
            return; -- Exit main function
        },
        AppError::Overflow => { --[[AI used block-expr style stuff, and forgot to add break cuz of it]]
            println!("Error: Number too large.");
            0.0
        }
        -- If other errors exist that aren't matched, they are propagated (soft error if main doesn't return Result)
    };

    println!("Sqrt result: {}", result);

    -- 7. Match Statements
    -- Match must handle all inputs (or a soft-error is inserted with a default case)
    let val = 2;
    match val {
        1 => println!("One"),
        2 => println!("Two"),
        _ => println!("Other") -- Default case
    }

    -- 8. Enums and Options
    ex enum Option(T = type) {
        None,
        Some(T)
    }

    -- Constructing the Some variant using braces { }
    let maybe_number = Option::Some{u32}(42);--[[AI swapped the arg styles oops]]
    
    match maybe_number {
        Option::None => println!("No number"),
        Option::Some(n) => println!("Number is {}", n) --[[AI used () for match]]
    }

    -- 9. Using the struct function defined earlier
    let my_dims = Dimensions(1920, 1080);
    println!("Dimensions: {}x{}", my_dims.width, my_dims.height);--[[AI indexed into type]]
    println!("Area: {}", my_dims.area);

    -- 10. Lambdas
    -- Lambda syntax: |args| -> ReturnType { body }
    -- Params use `Name = Type`
    let add = |a = i32, b = i32| -> i32 => a + b; --[[AI didnt expect overflow]]
    println!("Lambda add 5 + 3 = {}", add(5, 3));
    
    -- Lambda with capture
    let multiplier = 2;
    let multiply = |x = i32| -> i32 => x * multiplier; --[[AI didnt expect overflow]]
    println!("Lambda multiply 5 * 2 = {}", multiply(5));
}
