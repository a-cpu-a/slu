#
# Dependencies: basic, type
#

Subtypes {
	
	int literals: ..., -2,-1,0,1,2, ...
	float literals.
	string literals: "", "a", "b"
	
	0.0_f32 < f32
	0.0_f64 < f64
	
	
	1 < 0||1
	0||1 < 0..1
	1||2||3||4 < 1..4
	
	"a" < "a"||"b"
	"a"||"b" < &char
	&char < &str
	"" < &str
	""||"a" < &str
	
	"" < String
	"a"||"b" < String
	
	-----------
	
	Name matching -> {
		if both unnamed / same name, then return true;
		--the names dont match...
		
		if super-type has no name, then return false;
		
		--potential sub type upcast?
		--or maybe a constructor?
		
	} named types are supertypes of unnamed types.
	(or maybe the other way around?) (you can assign unnamed struct to a named struct var)
	
	String <= String / Int <= Int / Float <= Float
	1. equal
	
	Float <= FloatType
	1. same float type?
	
	Int <= Range
	1. int inside range?
	
	Range <= Range
	1. does it fully contain the other range?
	
	Struct <= Struct
	1. names must match
	2. check if the subtype's fields are subtypes of the super-type's versions of those fields. (super exclusive fields are ignored).
	
	Union <= Union
	1. names must match
	2. all cases match exactly, unless they are refs, then lifetime outlives
	
	Variant <= Variant
	1. check if the subtype's variants are in the super-type.
	
	T < Variant
	1. is the subtype(or one of its supertypes) inside the variant.
	
	Slice <= Slice
	1. types must match exactly, unless they are refs, then lifetime outlives.
	
	Ref <= Ref
	1. do types match exactly, unless they are refs, then lifetime outlives.
	2. lifetime outlives
	
	--todo: impl recursive types.
	Rec <= Rec
	1. exact match on variable
	2. exact match on type
	
	
	-----------
	
	let mut x = "";
	x = "a";
	x = "b";
	--type of x = mut ""||"a"||"b"
	
	-----------
	
	let y = 5; --type = 5
	
	let u8 x = y;
	
	-----------
	
	let mut x = 4;
	let y = x;
	let z = y;
	x = z; --error, due to recursion, in theory (type = mut 4)
	
	-----------
	
	let mut x = 0;
	x = x + 1; -- error, cuz having any range of values extends the type to infinity. (mut 0..)
	-->
	tx >= 0
	t_y >= +(tx,1)
	tx >= t_y
	
	tx >= +(tx,1) -- wait that makes no sense
	
	-----------
	
	let mut x = 1;
	x = -x; --error, due to recursion, in theory (type = mut -1 || 1)
	-->
	tx >= 1
	t_y >= -(tx)
	tx >= t_y
	???
	
	-----------
	
	let mut x = 0;
	let y = 500-x;
	x = -y; --error, due to recursion
	-->
	tx >= 0
	ty >= 500-tx
	tx >= -ty
	
	ty >= 500
	tx >= -500
	
	ty >= 1000 --(500 - (-500))
	tx >= -1000
	
	-- error, it goes forever
	
	-----------
	
	let mut x = 1;
	x = 1-x; --error, due to recursion, in theory (type = mut 0..1)
	-->
	tx >= 1
	t_y >= -(1,tx)
	tx >= t_y
	
	tx >= 0 --(1-1)
	
	-----------
	
	let mut x = 0;
	let mut y = x;
	y = 3;
	x = y+x; -- error, cuz it explodes to infinity again
	-->
	tx >= 0
	ty >= tx
	ty >= 3
	t_z >= +(ty,tx)
	tx >= t_z
	-->
	ty >= 0
	tx >= +(ty,tx) -- wait, that makes no sense, it depends on itself!
}
