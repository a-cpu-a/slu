#
# Dependencies: basic, type
#

Subtypes {
	
	int literals: ..., -2,-1,0,1,2, ...
	float literals.
	string literals: "", "a", "b"
	
	0.0_f32 < f32
	0.0_f64 < f64
	
	
	1 < 0||1
	0||1 < 0..1
	1||2||3||4 < 1..4
	
	"a" < "a"||"b"
	"a"||"b" < &char
	&char < &str
	"" < &str
	""||"a" < &str
	
	"" < String
	"a"||"b" < String
	
	
	---------------------
	- Subtype inference -
	---------------------
	
	if only 1 type, then use that type.
	
	if any of the edit-types are errors, then the type is a error too.
	if any of the types are int or int-range, then the type is either a int or int-range (potentially inside a variant).
	if all of the types are floats of the same type, then the type is either float-const or float.
	if incompatible float types are mixed (f32+f64 for example), then the type is a error, also a error is logged.
	if all of the types are incompatible strings / unions / refs / slices / name-incompatible-structs, then the type is a variant of them.
	
	??? ({1} + {2} -> {1..2})
	
	-----------------
	- Subtype check -
	-----------------
	
	Name matching -> {
		if both unnamed / same name, then return true;
		--the names dont match...
		
		if use-type has no name, then return false;
		
		--potential sub type upcast?
		--or maybe a constructor?
		
		if the subtype implements SubtypeOf(super type), then return true;
		
		--should this exist?
		--if the use-type implements SupertypeOf(sub type), then return true;
		
		return false;
	}
	
	Near exact check -> {
		if one of them a type error, then return true;
		
		do type kinds match exacly? (Float != FloatType, Int != Range, Int==Int, ...)
		
		if the types are refs -> {
			use the normal subtype check.
		} else {
			do they match exactly?
		}
	}
	
	ErrorType <= * / * <= ErrorType
	1. always true
	
	String <= String / Int <= Int / Float <= Float
	1. equal
	
	Float <= FloatType
	1. same float type?
	
	Int <= Range
	1. int inside range?
	
	Range <= Int
	1. does the range only have that one int?
	
	Range <= Range
	1. does it fully contain the other range?
	
	Struct <= Struct
	1. names must match
	2. check if the subtype's fields are subtypes of the super-type's versions of those fields. (super exclusive fields are ignored).
	3. are the fields in the subtype also in the same order inside the super type.
	
	Union <= Union
	1. names must match
	2. all field names equal
	2. for all fields, near exact check
	
	Variant <= Variant
	1. check if the subtype's variants are in the super-type.
	
	T < Variant
	1. is the subtype(or one of its supertypes) inside the variant.
	
	Slice <= Slice
	1. near exact check on elem.
	
	Ref <= Ref
	1. near exact check on elem.
	2. lifetime outlives
	
	--todo: impl recursive types.
	Rec <= Rec
	???
	??? 1. exact match on variable
	??? 2. near exact check on type
	
	
	-----------
	
	let mut x = "";
	x = "a";
	x = "b";
	--type of x = mut ""||"a"||"b"
	
	-----------
	
	let y = 5; --type = 5
	
	let u8 x = y;
	
	-----------
	
	let mut x = 4;
	let y = x;
	let z = y;
	x = z; --error, due to recursion, in theory (type = mut 4)
	
	-----------
	
	let mut x = 0;
	x = x + 1; -- error, cuz having any range of values extends the type to infinity. (mut 0..)
	-->
	tx >= 0
	t_y >= +(tx,1)
	tx >= t_y
	
	tx >= +(tx,1) -- wait that makes no sense
	
	-----------
	
	let mut x = 1;
	x = -x; --error, due to recursion, in theory (type = mut -1 || 1)
	-->
	tx >= 1
	t_y >= -(tx)
	tx >= t_y
	???
	
	-----------
	
	let mut x = 0;
	let y = 500-x;
	x = -y; --error, due to recursion
	-->
	tx >= 0
	ty >= 500-tx
	tx >= -ty
	
	ty >= 500
	tx >= -500
	
	ty >= 1000 --(500 - (-500))
	tx >= -1000
	
	-- error, it goes forever
	
	-----------
	
	let mut x = 1;
	x = 1-x; --error, due to recursion, in theory (type = mut 0..1)
	-->
	tx >= 1
	t_y >= -(1,tx)
	tx >= t_y
	
	tx >= 0 --(1-1)
	
	-----------
	
	let mut x = 0;
	let mut y = x;
	y = 3;
	x = y+x; -- error, cuz it explodes to infinity again
	-->
	tx >= 0
	ty >= tx
	ty >= 3
	t_z >= +(ty,tx)
	tx >= t_z
	-->
	ty >= 0
	tx >= +(ty,tx) -- wait, that makes no sense, it depends on itself!
}
