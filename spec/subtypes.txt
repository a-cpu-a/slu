#
# Dependencies: basic, type
#

Subtypes {
	
	int literals: ..., -2,-1,0,1,2, ...
	float literals.
	string literals: "", "a", "b"
	
	0.0_f32 < f32
	0.0_f64 < f64
	
	
	1 < 0||1
	0||1 < 0..1
	1||2||3||4 < 1..4
	
	"a" < "a"||"b"
	"a"||"b" < &char
	&char < &str
	"" < &str
	""||"a" < &str
	
	"" < String
	"a"||"b" < String
	
	-----------
	
	Name matching -> named types are supertypes of unnamed types.
	(or maybe the other way around?) (you can assign unnamed struct to a named struct var)
	
	String x String / Int x Int / Float x Float
	1. equal
	
	Float x FloatType
	1. same float type?
	
	Int x Range
	1. int inside range?
	
	Range x Range
	1. does it fully contain the other range?
	
	Struct x Struct
	1. names must match
	2. TODO: ??? field counts must match? + ??? ?? ?? ???
	3. for now just check exact, unless its a ref.
	
	Union x Union
	1. name match & all fields match exactly, unless they are refs, then lifetime outlives
	
	Variant x T
	1. check subtyping for each variant elem
	
	Slices
	1. types must match exactly, unless they are refs, then lifetime outlives.
	
	Ref x Ref
	1. do types match exactly, unless they are refs, then lifetime outlives.
	2. lifetime outlives
	
	
	
	
	To keep things simple, no recursive type inference.
	
	
	-----------
	
	let mut x = "";
	x = "a";
	x = "b";
	--type of x = mut ""||"a"||"b"
	
	-----------
	
	let y = 5; --type = 5
	
	let u8 x = y;
	
	-----------
	
	let mut x = 4; --type = mut 4
	let y = x;
	let z = y;
	x = z;
	
	-----------
	
	let mut x = 0;
	x = x + 1; -- error, cuz having any range of values extends the type to infinity. (mut 0..)
	-->
	tx >= 0
	t_y >= +(tx,1)
	tx >= t_y
	
	tx >= +(tx,1) -- wait that makes no sense
	
	-----------
	
	let mut x = 1;
	x = -x;
	-->
	tx >= 1
	t_y >= -(tx)
	tx >= t_y
	???
	
	-----------
	
	let mut x = 0;
	let y = 500-x;
	x = -y;
	-->
	tx >= 0
	ty >= 500-tx
	tx >= -ty
	
	ty >= 500
	tx >= -500
	
	ty >= 1000 --(500 - (-500))
	tx >= -1000
	
	-- error, it goes forever
	
	-----------
	
	let mut x = 1;
	x = 1-x;
	-->
	tx >= 1
	t_y >= -(1,tx)
	tx >= t_y
	
	tx >= 0 --(1-1)
	
	-----------
	
	let mut x = 0;
	let mut y = x;
	y = 3;
	x = y+x; -- error, cuz it explodes to infinity again
	-->
	tx >= 0
	ty >= tx
	ty >= 3
	t_z >= +(ty,tx)
	tx >= t_z
	-->
	ty >= 0
	tx >= +(ty,tx) -- wait, that makes no sense, it depends on itself!
}
