#
# Dependencies: basic, type, exportPrefix, comptime, library(TODO), annotation, fnStatement
#

"std::macros" Module {
	
	--These types are only available at comptime
	
	ex struct Block = @Builtin{"base::type/block"}Unit;
	ex struct Stat = @Builtin{"base::type/stat"}Unit;
	
	ex struct Expr = @Builtin{"base::type/exp"}Unit;
	ex struct Name = @Builtin{"base::type/Name"}Unit;
	ex struct TraitExpr = @Builtin{"base::type/traitExp"}Unit;
	
	--
	--wrap around one of the above things, to allow a list of someting
	--note: only works for: (Name,TraitExpr,Expr)
	--
	ex struct fn CommaList(T = type) = @Builtin{"base::type/CommaList"}T;
	
	--These return the tokens raw, without splicing them
	
	--Do NOT use @Builtin{"base::no_splice"} in your own code, as it is only supported here.
	--The ! after the name, makes it so it doesnt conflict with the types.
	--It also means you cant call these in function-form
	@Builtin{"base::no_splice"} ex macro fn Block!{macro v = Block}->Block {return v;}
	
	@Builtin{"base::no_splice"} ex macro fn Stat! {macro v = Stat }->Stat {return v;}
	
	@Builtin{"base::no_splice"} ex macro fn Expr! {macro v = Expr }->Expr {return v;}
	@Builtin{"base::no_splice"} ex macro fn Name! {macro v = Name }->Name {return v;}
	@Builtin{"base::no_splice"} ex macro fn TraitExpr! {macro v = TraitExpr}->TraitExpr {return v;}
	
	@Builtin{"base::no_splice"} ex macro fn CommaList!{T = type,macro v = CommaList(T)}->CommaList(T) {return v;}
	
	--[=[
	--TODO: move this elsewhere, when its needed
		fn prefixUpperify(prefix = &str,s = mut String) -> String {
			if (s:len() == 0) return prefix;
			s[1] = s[1].upper()
			return prefix++s;
		}
	]=]
	
	--[=[
	
	--
	-- This is a example, for how to create a macro that instantly splices what you pass to it
	--
	-- (addType!{u8}) -> (u8)
	--
	-- You can also call it like a normal function (you also need to use "()"),
	-- and it will return what you called it with, and nothing will change.
	--
	-- assertEq!(addType(Expr!{u8}), Expr!{u8});
	--
	
	macro fn implAdd(macro ns = CommaList(Name)) -> Vec(Stat) {
		
		let Vec(Stat) r;
		
		for (k,v in ns) {
			let name = ("add"++(v as str)) as Name;
			r:push(
				Stat!{
					ex macro fn @(name) {macro @(v) val } {
						return val
					}
				}
			);
		}
		
		return r;
	}
	
	implAdd!(
		Block,
		Stat,
		
		Expr,
		Name,
		TraitExpr
	);
	]=]
	
	Implementation {
		The types may be implemented as "Userdata" or "ptrdata", with extra data
		
		Using them outside of comptime or macros must produce a compile-time error
	}
	
}


New Syntax {

	macroSplice ::= "@(" comptimeExp ")"
	
	
	macroArgs ::= "(" ProgrammableArgs ")" | "{" ProgrammableArgs "}" | "[" ProgrammableArgs "]" | exp | stat | retstat
	macroInvoke ::= comptimeVar"!" macroArgs
	macroInvSpl ::= macroInvoke | macroSplice
	
	stat @::= | macroInvSpl
	basicExp @::= | macroInvSpl
	Name @::= | macroInvSpl
	traitExp @::= | macroInvSpl
	OptExportPrefix @::= | macroInvSpl
	comptimeVar @::= | macroInvSpl
	
	macroParam ::= ["macro"] typedParam
	macroParamList ::= macroParam {"," macroParam}
	
	macroParamsBlock ::= ("(" macroParamList ")")
		| ("[" macroParamList "]")
		| ("{" macroParamList "}") 
		| (">!(" macroParamList ")!<")
	
	PreMacro ::=
	
	stat @::= | OptExportPrefix PreMacro "macro" "fn" Name ["!"] macroParamsBlock ["->" basicExp] "{" block "}"
	
}

New Keywords {
	macro
}

Macro {
	
	--TODO: a way to splice out basic keywords, like "mut", "ex" and "const"
	-- maybe token sequences?
	
	Creates a new global or local macro with a name 'Name', that cant be modified.
	
	Macro's must return one of the macro types (or a simple container of them), if you need to return something else, use a const function.
	
	macroSplice -> splices the token sequence(s) resulting from a expresion
	macroInvoke -> run a macro & splice it.
	The ">!(" ")!<" args mean that there is nothing surrounding the args.
	"macro" functions are ran at comptime.
	
	macroInvoke gets turned from 
	```slu
	macroWithArgs_Name_Stat!(myNameArg,local x = 44)
	```
	into 
	```slu
	@(macroWithArgs_Name_Stat(Name!{myNameArg},Stat!{local x = 44}))
	```
	
	Adding "macro" before a argument, makes it modify parsing behaviour, when
		using "macroInvoke", if there is no macro, then you need to pass it by value.
	
	You can call macro-functions like normal const functions.
	When doing that, you also need to use "()".
	
	When using ">!( )!<", you cant have more than 1 argument, and it cant be a list.
	
	If you have a CommaList in your args, it must be the last argument.
	
	adding a ! after the name of a macro def, makes it so it doesnt
	conflict with existing symbols,	it also means you cant call them in function-form
	
	@@ is converted to @.
	
	Error messages from macro code include both the macro splice-stack, and the place where it was spliced from.
	
	Implementation {
		
		Could be parsed without resolving into syntax elements, and then desugared into the real expression, statement, etc.
		
		Could be implemented by wrapping the input stream temporarily, while something needs to be spliced in.
	}
}