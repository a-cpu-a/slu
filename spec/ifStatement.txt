#
# Dependencies: basic, type
#

New Syntax {
	
	ifcondBasic ::= "if" basicExp
	
	--Note: retstat as used in blockOrRet, cant use the `else` operator, as it would conflict with if-stat parsing
	stat @::= | ifcondBasic blockOrRet {"else" ifcondBasic blockOrRet} ["else" blockOrRet]
	stat @::= | ifcondBasic "=>" exp

	unop @::= | "if" exp "=>"
	binop @::= | "else"
}

New Keywords {
	if
	else
}

If Statement {
	
	Lets you check if a result is in the error or value state.

	The `else` operator takes 2 expressions, the left one must be a result R, the right one must have the same type as R's value.
	Else checks if the Result on the left is a Ok, returning that if so, otherwise it returns the value of right.
	
	The return type is assigned automatically, if missing.
	When in expressions, the return type is not decayed into a value, unless explicitly set as such, or if one of the cases would return a value.
	```slu
	--Both y and z are dropped, due to the possibility that x is either value.
	drop if x => y else z;
	
	--Since they dont decay unless needed, you can put the ref operator outside the if.
	let */y/z selected = &(if x => y else z)
	```

	The reason for the alternative syntax specifically for statements, is cuz it doesnt need `=>`, and it doesnt return anything.
	
	```slu

	let x = if Q
			  => 0
			else 1

	if Q => 100
	else if Q => 100
	else if Q => {1,2,3}
	else if Q => do {return 100;}
	else if Q => print("Hello")
	else		do {print("Hello");}
	
	if Q {} else if Q {} else {}

	if Q
		return 1; 
	else if Q
		return 2; 
	else 
		return 3;

	```
	
	Implementation {
		May be a jump table, if else chain, etc.
	}
}