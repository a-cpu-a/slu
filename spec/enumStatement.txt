#
# Dependencies: basic, annotation, export
#

New Syntax {
	enumfield ::= [annotations] optexport Name [tableconstructor] {outerAnnotation}
	globstat @::= | optexport "enum" Name ["(" [params] ")"] "{" {enumfield fieldsep} [".."] "}"
}

New Keywords {
	enum
}

Enum Statement {
	
	Defines a new enum type.
	
	Enums can only contain one of the fields that are inside the field-list.
	
	Using enums is safe, as they store the active option they use.
	
	Adding `..` to the end, marks the enum as non-exhaustive, so its size may change, and new variants may be added.

	The layout is defined by annotations.
	The default layout is optimized for size & speed, and can change depending on where it is used.
	Of course it can be fixed to a standard format, by using (TODO: ???), however this will prevent some optimizations.
	
	```slu
	enum Option(T = type) {
		None,
		Some{T}
	}

	-- Desugars into the following:

	---Returns a nominally unique type, because its a "struct" fn, so you cant make a Option
	--- yourself by doing `None(T) | Some(T)`, only this function can return a Option.
	struct fn Option(T = type) 
	{
		--Note: T in the following statements cant refer to the local variable T, because they are global statements.
		
		---Nominally unique unit type
		---None(u8) is not the same as None(u16)
		struct None(T = type) {};
		
		---Nominally different to T
		struct Some(T = type) {T};

		--[[
		impl(T) SubtypeOf(Option(T)) for None(T) {
			fn upcast(self) -> Option(T) { return Option(T){self} }
		}
		impl(T) SubtypeOf(Option(T)) for Some(T) {
			fn upcast(self) -> Option(T) { return Option(T){self} }
		}
		]]
		
		--Not a global statement, so T is the arg.
		return None(T) || Some(T);
	}

	--Use it: Option::Some(u8), Option(u8) Option::Some{100} Option::None{} Option::None
	```
	
	Implementation {
		Must support at least 32768 fields.
	}
	
	archive { --[[ @BuiltinSubTypeOf(Option(T)) ]] }
}
