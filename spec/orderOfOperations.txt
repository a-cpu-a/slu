#
# Dependencies: basic
#

Order of Operations {
	
	
	```
	(pseudo) ;
	(pseudo) = --Maybe add compound operators: ||= ++= **= |= ~= &= <<= >>= += -= %= *= /= //= ^=
	(pseudo) ,
	
	(pseudo) if => else
	
	unary operators (mut	alloc)
	
	or
	and
	
	!=	==
	
	<	>	<=	 >=
	
	as
	
	~~
	|| --union operator

	union --struct/tuple/table to union-type op
	
	++
	**
	
	binary, post and prefix range operators (..)
	
	|	~	&	--(Not the same as most langs! they are all equal)
	<<	 >>
	unary operators(dyn impl) --NOTE: when this operator is used, it will consume all additions after it, no precedences matter!
	+	-
	% --(Not the same as most langs, modulus is bellow / * //)
	*	/	//
	unary operators (!	-	&   &const   &mut   &share   *   *const	  *mut	 *share	  [])
	^
	postfix unary operators (? .*)
	
	(pseudo) .	.:	 ::	  function-args""()[[]] construct{} index[]
	(pseudo) (parenthesis)
	```
	Everything is left to right, except for <<, >> and ^ which are right to left
	(non-postfix unary operators are also right to left)
	
	
	traits used for every operator
	```
	()		FnOnce Fn FnMut FnConst FnShare
	--$$=		$$Assign
	..		???			(Ranged/Ranging/Bounds/Bound/Boundable/??? .range .rangeMax .rangeMin)
	?		Try.branch
	!		Not
	>		(Partial)Ord.gt
	<		(Partial)Ord.lt
	>=		(Partial)Ord.ge
	<=		(Partial)Ord.le
	==		(Partial)Eq.eq
	!=		(Partial)Eq.ne
	<<		Shl
	>>		Shr
	~		Xor
	&		BitAnd
	and		And ?or? BoolAnd
	|		BitOr
	or		Or ?or? BoolOr
	++		Concat
	**		Rep
	+		Add
	-		Neg
	-		Sub
	^		Pow
	%		Rem
	/		Div
	//		FloorDiv
	*		Mul
	.*		Deref
	
	--internal use:
	*		RefType			(unstable)
	*const	RefTypeConst	(unstable)
	*mut	RefTypeMut		(unstable)
	*share	RefTypeShare	(unstable)
	&		Ref			(unstable)
	&const	RefConst	(unstable)
	&mut	RefMut		(unstable)
	&share	RefShare	(unstable)
	
	[]		Slicify		(unstable)
	.		----		
	.:		----		
	::		----		
	as		As.asType
	~~		----
	||		Union.union
	dyn		----
	impl	----
	mut		MarkMut		(unstable)
	alloc	----
	=		----		(maybe...) Move + Relocate.reloc()?
	```
	
	
	Examples, where no difference exists, if you remove braces
	
	```slu
	
	
	true or (false and true)
	
	(!1) / (-1)
	1 / (-1)
	1 / (&(x.*))
	1 / (!(x.*))
	(x.*) / 1
	((x?).*) / 1
	(1 / (-1))..
	((1..) / 1)..
	(..((1..) / 1))..
	(..((x?)?))..
	(..(&(..((((x?)?)?)?))))..
	&(mut (x ..))
	&(mut ((..(x?))..))
	&(mut (..(((x?)..) ^ 5)))
	&(mut ((5 ^ (..(x?)))..))
	(1+1)..
	
	!(1 ^ (-1))
	1 ^ (-1)
	1 ^ (&(x.*))
	1 ^ (!(x.*))
	(x.*) ^ 1
	((x?).*) ^ 1
	(1 ^ (-1))..
	((1..) ^ 1)..
	(..(((1..) ^ 1)))..
	
	(((x?).*)..)
	!(x ^ 10)
	x^(y?)
	
	((1|2)|4) & x
	
	((1 ~ 8) | 4) & 2
	(((1 | 4) & 56) ~ 5)
	(((1 + 0x16) | 0x10) ~ 0x11)
	
	(1 + (1 % 1)) + 1
	1 + (1 % (100*100))
	(100 - (1 % 100)) + 1
	
	(1 < 3) and (3 > 5)

	(1 & 5) != 0

	(1 | 4) == 5

	((1 << 3) | (5 >> 4)) == 5


	("aaa" ++ "444") ++ (3 != y)

	(1 >> 4) ++ "Hi!"


	(1 + 5) << 3


	"x==5: " ++ (x == 5)

	..(1+1)
	
	(1+1)..
	
	1 .. (1+3)
	
	"Range: " ++ (1 .. 4)

	"X: " ++ (1 | 5)
	
	( f()? ) ^ ( f()? )
	
	
	
	```
	
}