#
# Dependencies: basic
#

Order of Operations {
	
	
	```
	(pseudo) ;
	(pseudo) =
	(pseudo) ,
	(pseudo) try   match
	
	else
	if =>
	
	or
	and
	
	unary operators (ex   mut   @Xxx{})
	
	!=   ==
	
	<   >   <=   >=
	
	as
	
	~  --mk result type op, both unary and binary
	|	--union operator

	unary operators (union   *   *const   *mut   *share   [])	--struct/tuple/table to union-type op, ref type ops, slicify
	
	++
	**
	
	binary, post and prefix range operators (..)
	
	unary operators (dyn impl)
	%	--(Not the same as most langs, modulus is below / * //)
	+   -
	*   /   //
	unary operators (!   -   &   &const   &mut   &share)
	^
	postfix unary operators (?   .*)
	
	(pseudo) .   .:   ::   function-args""()[[]]   construct{}   index[]
	(pseudo) (parenthesis)
	```
	Everything is left to right, except for `=`, `else` and `^` which are right to left
	(non-postfix unary operators are also right to left)
	
	
	traits used for every operator
	```
	()		FnOnce Fn FnMut FnConst FnShare
	--$$=		$$Assign
	..		???			(Ranged/Ranging/Bounds/Bound/Boundable/??? .range .rangeMax .rangeMin)
	?		Try.branch
	!		Not
	>		(Partial)Ord.gt
	<		(Partial)Ord.lt
	>=		(Partial)Ord.ge
	<=		(Partial)Ord.le
	==		(Partial)Eq.eq
	!=		(Partial)Eq.ne
			Shl
			Shr
			Xor
			BitAnd
	and		And
			BitOr
	or		Or
	++		Concat
	**		Rep
	+		Add
	-		Neg
	-		Sub
	^		Pow
	%		Rem
	/		Div
	//		FloorDiv
	*		Mul
	.*		Deref
	
	--internal use:
	*		RefType			(unstable)
	*const	RefTypeConst	(unstable)
	*mut	RefTypeMut		(unstable)
	*share	RefTypeShare	(unstable)
	&		Ref			(unstable)
	&const	RefConst	(unstable)
	&mut	RefMut		(unstable)
	&share	RefShare	(unstable)
	
	[]		Slicify		(unstable)
	.		----		
	.:		----		
	::		----		
	as		As.asType
	~		----
	|		Union.union	(unstable)
	dyn		Dynify		(unstable)
	ex		MarkEx		(unstable)
	else	----		
	if =>	----		
	@Xxx{}	----		
	impl	Implify		(unstable)
	mut		MarkMut		(unstable)
	=		----		(maybe...) Move + Relocate.reloc()?
	```
	
	
	Examples, where no difference exists, if you remove braces
	
	```slu
	
	
	x or (y and z)
	
	(!1) / (-1)
	1 / (-1)
	1 / (&(x.*))
	1 / (!(x.*))
	(x.*) / 1
	((x?).*) / 1
	(1 / (-1))..
	((1..) / 1)..
	(..((1..) / 1))..
	(..((x?)?))..
	(..(&(..((((x?)?)?)?))))..
	&(ex (x ..))
	&(ex ((..(x?))..))
	&(ex (..(((x?)..) ^ 5)))
	&(ex ((5 ^ (..(x?)))..))
	(1+1)..
	
	!(1 ^ (-1))
	1 ^ (-1)
	1 ^ (&(x.*))
	1 ^ (!(x.*))
	(x.*) ^ 1
	((x?).*) ^ 1
	(1 ^ (-1))..
	((1..) ^ 1)..
	(..(((1..) ^ 1)))..
	
	(((x?).*)..)
	!(x ^ 10)
	x^(y?)
	
	--((1 bitor 2) bitor 4) bitand x
	
	--((1 bitxor 8) bitor 4) & 2
	--(((1 bitor 4) & 56) bitxor 5)
	--(((1 + 0x16) bitor 0x10) bitxor 0x11)
	
	(1 + (1 % 1)) + 1
	1 + (1 % (100*100))
	(100 - (1 % 100)) + 1
	
	(1 < 3) and (3 > 5)

	--(1 bitand 5) != 0

	--(1 bitor 4) == 5

	--((1 bitshl 3) bitor (5 bitshr 4)) == 5


	("aaa" ++ "444") ++ (3 != y)

	(1 bitsr 4) ++ "Hi!"


	--(1 + 5) bitshl 3


	"x==5: " ++ (x == 5)

	..(1+1)
	
	(1+1)..
	
	1 .. (1+3)
	
	"Range: " ++ (1 .. 4)

	"X: " ++ (1 | 5)
	
	( f()? ) ^ ( f()? )
	
	
	
	```
	
	archive {


		```
		--Why `else` is R2L
		(
			(((
				if getAe() => A{}
			) as A~Ae) else ((
				if getSo() => B{}
			) as B~So)
			as A | B~So)
		--Umm you cant feed that union type into the left side of an else?
		else (e as E))
		```

		```
		return x > 0 => 1 
		else x == 0 => 0 
		else -1
		```

		```
		return x > 0
		  => 1 
		else x == 0
		  => 0 
		else -1
		```

		```
		return (
			x > 0
				=> 1 
			else x == 0
				=> 0 
			else -1
		)
		```

		```
		return if x > 0
		  => 1 
		else if x == 0
		  => 0 
		else -1
		```

		Soo, i dont think its a good idea to remove it,
		as either it requires a block `(...)` which makes it kinda ugly,
		or its a bit misleading: `return x>0` but the next line changes it completely. 
		Putting the check & result on one line takes up too much space.
	}
}

Sources {
	https://justinpombrio.net/2025/09/22/imagining-a-language-without-booleans.html
}
