#
# Dependencies: basic, type
#

Sized Trait {

	Illegal to implement manually. (todo: a unsafe way to implement it)
	
	fn size(&self) -> MemSize;
}
UniSized Trait {

	If this is present, implements Sized automatically.
	Illegal to implement manually. (todo: a unsafe way to implement it)
	
	const MemSize uni_size;
}
Aligned Trait {

	Illegal to implement manually.
	
	fn alignment(&self) -> Alignment;
}
UniAligned Trait {
	
	If this is present, implements Aligned automatically.
	Illegal to implement manually. (todo: a unsafe way to implement it?)
	
	const Alignment uni_alignment;
}

Type Sizes {
	
	Some types have no size defined at compile-time, including slices ([]T), functions and dyn types.
	
	If a type doesnt implement Sized, then it has no known size, meaning it is impossible to use it in some cases, like Vec.
	
	Just because they have no compile-time size, doesnt mean you cant store them inside another type.
	They could be stored with a size attached, or the size could be infered from the data (null terminated for example).
	
	Pointers/references to these types might include a size, if they are slices.
	Pointers/refs to dyn's dont have such info, since you can use the vtable to find the size.
	
	`[]u8` -> slice of u8, could have any size.
	`fn{} -> Unit` -> bytes of a function, could have any size, depending on the code within it.
	`dyn Add` -> bytes of a type that implements some trait, could have any size
	
	Implementation {
		dynamically sized types may be boxed only when its impossible/impractical to not do it. (prob jvm (only if trying to avoid jni))
	}
}
