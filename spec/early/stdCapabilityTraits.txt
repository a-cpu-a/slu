#
# Dependencies: basic, type 
#

Capability Traits {
	each cap trait has 3 associated functions.
	`defaultX` -> `Option(impl X)`
	`defaultXOrDummy` -> `impl X` -- If not found, returns a dummy implementation
	
	all methods take `*mut self` or `*self`
}

Debug Trait {
	--Dummy says !attached, and empty breakpoint fn, voids debug logs
	fn attached(*self)->bool
	fn breakpoint(*self)
	
	--debug logging
	fn log(*mut self, "fmt-str",FmtArgs) -> Unit
}

--TODO: how should stack traces be handled? - TODO: look into zig

Panic Trait {
	--Dummy tries to exit/terminate or just loop forever.
	
	--maybe a stack trace arg?
	fn panic(*self,msg = *str, ?)
}

Alloc Trait {
	--Dummy version always returns oom, ignores frees.
	
	AlErr Struct {
		-- can be anything, even oom, but also heap corruption, ...
	}
	AllocRes Enum {
		Expand{newPtr = PtrShare(Byte)},		--Expands this allocation, and you move the bytes yourself if you need to. (can move the pointer to the left a bit!)
		New{newAllocation = PtrShare(Byte)},	--Makes a new allocation, you free this one, and move the bytes yourself.
		Moved{newPtr = PtrShare(Byte)}			--Similar to C's realloc(), yes this does allow it to be overlapping too.
	}
	
	--Any 0 sized allocation may be stored as a 0 pointer.
	--if ptr is 0, then a new allocation will be formed, always returning `AllocRes::New`
	--If the alignment is invalid, then this will panic.
	unsafe fn alloc(*self, ptr = PtrShare(Byte), size = MemSize, align = Alignment) -> AllocRes~AlErr
	
	fn alignedMalloc(*self, size = MemSize, align = Alignment) -> PtrShare(Byte)~AlErr {unsafe{ return self.alloc(0 as PtrShare(Byte),size,align)? }}
	fn malloc(*self, size = MemSize) -> PtrShare(Byte)~AlErr { return self.alignedMalloc(size,Alignment::Bytes{1}) }
	unsafe fn free(*self, ptr = PtrShare(Byte)) -> Unit~AlErr {unsafe{ self.alloc(ptr,0)? }}
	--alloc() can be more efficient, however if you always need to move it, then this is the correct choice.
	unsafe fn realloc(*self, ptr = PtrShare(Byte),size = MemSize, align = Alignment) -> PtrShare(Byte)~AlErr { unsafe {--[=[TODO: complex match based solution using self.alloc!]=]} }
	
	--Report that a pointer is leaked, does not do anything, ment to be hooked with debug logging that logs this.
	fn reportMemLeak(*self, ptr = PtrShare(Byte)) -> Unit
}

Fs Trait {
	
	--Dummy version ignores all writes & says all folders are empty.
	
	???
	openFile?
	listDir?
	mkDir?
	mkFile?
}

Clock Trait {
	
	--Dummy version says now() is 0 / epoch
	
	--maybe something that supports arbitrary units? maybe even arb. precision?
	now(*self) -> ?
	nowMilis(*self) -> std::unit::ms(u64)?
}

Log Trait {
	
	--Dummy version contains empty impls for all the functions
	--TODO: maybe err..emerg should return errors?
	
	emerg(*mut self, "fmt-str",FmtArgs) -> Unit
	alert(*mut self, "fmt-str",FmtArgs) -> Unit
	crit(*mut self, "fmt-str",FmtArgs) -> Unit
	
	err(*mut self, "fmt-str",FmtArgs) -> Unit
	warn(*mut self, "fmt-str",FmtArgs) -> Unit
	
	notice(*mut self, "fmt-str",FmtArgs) -> Unit
	info(*mut self, "fmt-str",FmtArgs) -> Unit
}

Env Trait {
	
	--Dummy version reports 0 env vars, no args, empty work dir.
	
	?unsafe? envVar(?) -> ?
	?unsafe? setEnvVar(?) -> Unit
	args() -> ?
	workDir() -> ?
}

Rng Trait {
	
	--Dummy version ...? no dummy version?
	
	secure(?) -> Result? Option?
	pseudo(?) -> ?
}

Net Trait {
	
	--Dummy version cant connect to anything / errors.
	
	tcp?
	udp?
	dns?
}

Sys Trait {
	
	--Dummy version always returns errors.
	
	newProc?
	exit?
	pid?
	signals?
}


Sources {
	https://gist.github.com/leecannon/d6f5d7e5af5881c466161270347ce84d
}