#
# Dependencies: basic, type 
#

Capability Traits {
	each cap trait has 3 associated functions.
	`defaultX` -> `Option(impl X)`
	`defaultXOrDummy` -> `impl X` -- If not found, returns a dummy implementation
	
	all methods take `&mut self`
}

Debug Trait {
	--Dummy says !attached, and empty breakpoint fn, voids debug logs
	fn attached()->bool
	fn breakpoint()
	
	--debug logging
	fn log("fmt-str",FmtArgs) -> Unit
}

--TODO: how should stack traces be handled? - TODO: look into zig

Panic Trait {
	--Dummy tries to exit/terminate or just loop forever.
	
	--maybe a stack trace arg?
	fn panic(msg = &str, ?)
}

Alloc Trait {
	--Dummy version always returns oom, ignores frees.
	
	AlErr Struct {
		-- can be anything, even oom, but also heap corruption, ...
	}
	AllocRes Enum {
		Expand{newPtr = *share byte},		--Expands this allocation, and you move the bytes yourself if you need to. (can move the pointer to the left a bit!)
		New{newAllocation = *share byte},	--Makes a new allocation, you free this one, and move the bytes yourself.
		Moved{newPtr = *share byte}			--Similar to C's realloc(), yes this does allow it to be overlapping too.
	}
	
	--Any 0 sized allocation may be stored as a 0 pointer.
	--if ptr is 0, then a new allocation will be formed, always returning `AllocRes::New`
	--If the alignment is invalid, then this will panic.
	unsafe fn alloc(ptr = *share byte, size = MemSize, align = Alignment) -> AllocRes~~AlErr
	
	fn alignedMalloc(size = MemSize, align = Alignment) -> *share byte~~AlErr {unsafe{ return self.alloc(0 as *share byte,size,align)? }}
	fn malloc(size = MemSize) -> *share byte~~AlErr { return self.alignedAlloc(size,Alignment::Bytes{1}) }
	unsafe fn free(ptr = *share byte) -> Unit~~AlErr {unsafe{ self.alloc(ptr,0)? }}
	--alloc() can be more efficient, however if you always need to move it, then this is the correct choice.
	unsafe fn realloc(ptr = *share byte,size = MemSize, align = Alignment) -> *share byte~~AlErr { unsafe {--[=[TODO: complex match based solution using self.alloc!]=]} }
	
	--Report that a pointer is leaked, does not do anything, ment to be hooked with debug logging that logs this.
	fn reportMemLeak(ptr = *share byte) -> Unit
}

Fs Trait {
	
	--Dummy version ignores all writes & says all folders are empty.
	
	???
	openFile?
	listDir?
	mkDir?
	mkFile?
}

Clock Trait {
	
	--Dummy version says now() is 0 / epoch
	
	now() -> ?
	nowMilis() -> std::unit::ms(u64)?
}

Log Trait {
	
	--Dummy version contains empty impls for all the functions
	--TODO: maybe err..emerg should return errors?
	
	emerg("fmt-str",FmtArgs) -> Unit
	alert("fmt-str",FmtArgs) -> Unit
	crit("fmt-str",FmtArgs) -> Unit
	
	err("fmt-str",FmtArgs) -> Unit
	warn("fmt-str",FmtArgs) -> Unit
	
	notice("fmt-str",FmtArgs) -> Unit
	info("fmt-str",FmtArgs) -> Unit
}

Env Trait {
	
	--Dummy version reports 0 env vars, no args, empty work dir.
	
	?unsafe? envVar(?) -> ?
	?unsafe? setEnvVar(?) -> Unit
	args() -> ?
	workDir() -> ?
}

Rng Trait {
	
	--Dummy version ...? no dummy version?
	
	secure(?) -> Result? Option?
	pseudo(?) -> ?
}

Net Trait {
	
	--Dummy version cant connect to anything / errors.
	
	tcp?
	udp?
	dns?
}

Sys Trait {
	
	--Dummy version always returns errors.
	
	newProc?
	exit?
	pid?
	signals?
}


Sources {
	https://gist.github.com/leecannon/d6f5d7e5af5881c466161270347ce84d
}