#
# Dependencies: basic, annotation, traitStatement, comptime, type 
#

New Syntax {
	
	--Since there is a trait expr, the type expression doesnt parse binary operators, unless the trait expr was already parsed.
	globstat @::= | OptExportPrefix ["unsafe"] ["defer"] "impl" ["(" paramList ")"] [traitExp "for"] basicExp [whereClauses] "{" {globstat} "}"
}

New Keywords {
	defer
	where
	impl
	for
}

Impl Statement {
	
	Implements a trait for something.
	
	Inside impls, any code can use "Self" to refer to the type/trait-combo the impl is for.
	
	Impls allow you to define functions for other types (and trait combinations), in a less repetetive way.
	
	The values, for the items inside of the params are inferred from the impl usage sites, and the uses of the args within the impl.
	
	The expressions inside the impl definition must be simple aliases, including variables,
	and strong type functions, however, arbitrary functions are not allowed.
	This is to make matching types to impl's easy and simple.
	
	If your trait expr / basic expr need "()" around them you may need a empty param list, to keep things parsable.
	
	Adding `unsafe` is required if its unsafe to implement that trait, it is only allowed in the 'traitExp for' form.
	Adding 'defer', makes type checking happen only once the impl is actually used, allowing you to use T in any way you like.
}




Sources {
	https://doc.rust-lang.org/stable/reference/items/implementations.html
}
