#
# Dependencies: basic, annotation, traitStatement, comptime, type 
#

New Syntax {
	
	--Since there is a trait expr, the type expression doesnt parse binary operators, unless the trait expr was already parsed.
	globstat @::= | OptExportPrefix ["unsafe"] ["defer"] "impl" ["(" paramList ")"] [traitExp "for"] basicExp [whereClauses] tableconstructor
}

New Keywords {
	defer
	where
	impl
	Self
	for
}

Impl Statement {
	
	Implements a trait for something.
	
	Inside impls, any code can use "Self" to refer to the type/trait-combo the impl is for.
	
	Impls allow you to define functions for other types (and trait combinations), in a less repetetive way.
	
	The values, for the items inside of the params are inferred from the impl usage sites (if using defer), and the where clauses.
	Without "defer" the produced params are very opaque, so it is not possible to obtain knowlage about if the type implements X, unless it is specified in a where clause.
	
	The type inside the impl definition must have a name.
	(This is to make matching types to impl's easy and simple.)
	
	If your trait expr / basic expr need "()" around them you may need a empty param list, to keep things parsable.
	
	Adding `unsafe` is required if its unsafe to implement that trait, it is only allowed in the 'traitExp for' form.
	
	--Actually, is this a good idea? Why not do compiler magic to auto "add" it instead? (like when impl T, where T: ?Drop, or something?)
	--Will "defer" be used as a hack, to avoid adding any `T: ?Drop` style things, at the cost of simple dyn support?
	Adding 'defer', makes type checking happen only once the impl is actually used, allowing you to use T in any way you like.
}

Archive {
	
	--Alt form with expr as where bounds.
	impl(T=type) MyType(T) where T.implements(!Copy) {
		fn b(&self)->u8{return self.b}
		fn printA(&self) {println!("{}",self.a)}
	}
	impl(T=type) MyType(T) where T.implements(Copy) {
		fn b(&self)->u8{return self.b}
		fn printA(&self) {println!("{}",self.a)}
	}
	
	--Form where you implement structurally
	
	impl MyType(impl !Copy) {
		fn b(&self)->u8{return self.b}
		fn printA(&self) {println!("{}",self.a)}
	}
	impl MyType(impl Copy) {
		fn b(&self)->u8{return self.b}
		fn printA(&self) {println!("{}",self.a)}
	}
	-- Impls can be done like this too: (cant have ^^^, VVV and VVV at the same time!)
	impl struct(MyType){a=impl Display,b=u8} {
		fn b(&self)->u8{return self.b}
		fn printA(&self) {println!("{}",self.a)}
	}
	-- Or like this too: (this would basically be duck typed)
	defer impl MyType {
		fn b(&self)->u8{return self.b}
		fn printA(&self) {println!("{}",self.a)}
	}
	--(impl stat takes a type expression, that must eval to some nominal type)
}


Sources {
	https://doc.rust-lang.org/stable/reference/items/implementations.html
}
