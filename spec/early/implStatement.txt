#
# Dependencies: basic, annotation, traitStatement, comptime, type 
#

New Syntax {
	
	--Since there is a trait expr, the type expression doesnt parse binary operators, unless the trait expr was already parsed.
	globstat @::= | OptExportPrefix ["unsafe"] ["defer"] "impl" ["(" paramList ")"] [traitExp "for"] basicExp [whereClauses] "{" {globstat} "}"
}

New Keywords {
	defer
	where
	impl
	for
}

Impl Statement {
	
	Implements a trait for something.
	
	Inside impls, any code can use "Self" to refer to the type/trait-combo the impl is for.
	
	Impls allow you to define functions for other types (and trait combinations), in a less repetetive way.
	
	The values, for the items inside of the params are inferred from the impl usage sites, and the uses of the args within the impl.
	
	The expressions inside the impl definition must be simple aliases, including variables,
	and strong type functions, however, arbitrary functions are not allowed.
	This is to make matching types to impl's easy and simple.
	
	If your trait expr / basic expr need "()" around them you may need a empty param list, to keep things parsable.
	
	Adding `unsafe` is required if its unsafe to implement that trait, it is only allowed in the 'traitExp for' form.
	Adding 'defer', makes type checking happen only once the impl is actually used, allowing you to use T in any way you like.
}

Archive {
	
	--Alt form with expr as where bounds.
	impl(T=type) MyType(T) where T.implements(!Copy) {
		fn b(&self)->u8{return self.b}
		fn printA(&self) {println!("{}",self.a)}
	}
	impl(T=type) MyType(T) where T.implements(Copy) {
		fn b(&self)->u8{return self.b}
		fn printA(&self) {println!("{}",self.a)}
	}
	
	--Form where you implement structurally
	
	impl MyType(impl !Copy) {
		fn b(&self)->u8{return self.b}
		fn printA(&self) {println!("{}",self.a)}
	}
	impl MyType(impl Copy) {
		fn b(&self)->u8{return self.b}
		fn printA(&self) {println!("{}",self.a)}
	}
	-- Impls can be done like this too: (cant have ^^^, VVV and VVV at the same time!)
	impl struct(MyType){a=impl Display,b=u8} {
		fn b(&self)->u8{return self.b}
		fn printA(&self) {println!("{}",self.a)}
	}
	-- Or like this too: (this would basically be duck typed)
	defer impl MyType {
		fn b(&self)->u8{return self.b}
		fn printA(&self) {println!("{}",self.a)}
	}
	--(impl stat takes a type expression, that must eval to some nominal type)
}


Sources {
	https://doc.rust-lang.org/stable/reference/items/implementations.html
}
