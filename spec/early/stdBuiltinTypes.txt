#
# Dependencies: basic, type 
#

Integer Type {
	Kinda like `Int(-U128_MAX..U128_MAX)`, but without the utilities?
	
	No definition exists, as it is a compiler builtin. (under the hood its just a i129, to support i128 & u128)
	`struct Integer;`
}

Int Type {
	The integer/(literal) types.
	
	Its a zst, if RANGE.min == RANGE.max.
	
	This type has special inference rules:
	Any overlapping / adjacent Int types will merge, if there is a gap, then a error is thrown, so:
	`1..1, 2..2 => 1..2`
	`1..2, 2..3 => 1..3`
	`1..1, 3..3 => ERROR!`
	`1..1, 3..3, 2..2 => 1..3`
	
	No definition exists, as it is a compiler builtin. (under the hood its just the smallest mlir/llvm iN... type that can fit all the numbers)
	`struct fn Int(RANGE = Range(Integer,Integer));`
	
	Int(0..0) == 0 as type
	Int(0..255) == 0..255 as type
}

FloatType Enum {
	F32
	F64
	--maybe more one day.
}
FloatLit Type {
	The float literal types.
	
	No definition exists, as it is a compiler builtin. (under the hood its the correct float type)
	`struct fn FloatLit(KIND = FloatType);`
}

Float Type {
	The float literal types.
	Always a zst
	
	No definition exists, as it is a compiler builtin.
	`struct Float(VAL = FloatLit(KIND),KIND = FloatType) {}`
}

StringLit Type {
	The any string literal type.
	
	No definition exists, as it is a compiler builtin. (under the hood its just std::String)
	`struct StringLit;`
}

Str Type {
	The string literal types.
	Always a zst
	
	`struct Str(VAL = StringLiteral) {}`
}

Slice Type {
	The slice type.
	
	No definition exists, as it is a compiler builtin. (under the hood it may have a ptr, multiple lengths and strides... or be a zst)
	`struct fn Slice(T = type);`
}

Addr Type {
	An address inside of memory.
	`struct fn Ref(align = Lifetime, msp = Mspace);`
}

Ref and Ptr Types {
	The ref and ptr types.
	
	No definition exists, as it is a compiler builtin. (under the hood it may have a vtable, ptr, ... or even be a zst)
	`struct fn Ref(T = type, life = Lifetime, msp = Mspace);`
	`struct fn RefMut(T = type, life = Lifetime, msp = Mspace);`
	`struct fn RefShare(T = type, life = Lifetime, msp = Mspace);`
	`struct fn Ptr(T = type, life = Lifetime, msp = Mspace);`
	`struct fn PtrMut(T = type, life = Lifetime, msp = Mspace);`
	`struct fn PtrShare(T = type, life = Lifetime, msp = Mspace);`
}

Lifetime Type {
	The lifetime literal types.
	
	No definition exists, as it is a compiler builtin. (under the hood its basically just a Vec(String))
	`struct Lifetime;`
}

Mspace type {
	Used to identify a memory space for an address or reference.

	Ways mem-spaces have been used in the past:
	https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class
	(I think it makes sense to allow user-defined mem-spaces, but they will need special compilation support, so they may require a compiler plugin to compile any read/write)

	Potential ways to use this in the future:
	Since there arent any pointers in lua/js/java/..., there might be a mem-spaces like this:
	`lua::TableKey` and `lua::TableKeyAddr{tbl = lua::Table, key = lua::TableKey}`
	`js::ObjKey` and `js::ObjKeyAddr{obj = js::Object, key = js::ObjectKey}`
	`java::LambdaGetSet` and `java::LambdaGetSetAddr{lambda = java::GetSetLambda(java::Object)}` -- Prob something with invoke dynamic instead ...
}

Impure Type {
	Impure marker type, cant be created without some out of code stuff? toml stuff?
	
	`struct Impure {_ = struct {}}` --Includes a private field, so you cant create it
}

Struct Type {
	The struct literal types.
	
	No definition exists, as it is a compiler builtin. (under the hood its basically just a int)
	`struct fn Struct(???);`
}

Union Type {
	The union literal types.
	
	No definition exists, as it is a compiler builtin. (under the hood its basically just a int)
	`struct fn Union(???);`
}

Variant Type {
	A variant/union of multiple types.
	
	No definition exists, as it is a compiler builtin. (under the hood its basically just a int)
	`struct fn Variant(???);`
}
